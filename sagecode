A = 'aąbcčdeęėfghiįyjklmnoprsštuųūvzž '

def text2number (text):
    t = ''
    for r in text:
        if r in A:
            ind = A.index (r) + 1
            t += ('0' if ind < 10 else '') + str (ind)
    return int (t, 10)

#print (text2number('aa'), text2number('bcd'), text2number('we are'))

def number2text (M):
    n = M
    text = ''
    while n > 0:
        ind = n % 100 - 1
        text += A[ind] if 0 <= ind < len (A) else '?'
        n = n // 100
    return text[::-1]

#number2text (10203)

# Returns the list of solutions to the equation a*x ≡ b (mod n).
# Let d = gcd (a, n). There are no solutions if d does not divide b. Otherwise, there are d solutions.
# In particular, when gcd (a, n) = 1, there is only one solution: x ≡ b / a (mod n).
def solve_linear_congruence (a, b, n):
    d = gcd (a, n)
    if b % d != 0:
        return [] # no solutions
    new_n = n // d
    # gcd (a, new_n) = 1, so there is only one solution of the equation a*x ≡ b (mod new_n): x ≡ b / a (mod new_n)
    x0 = b / a % new_n
    solutions = [(x0 + k * new_n) % n for k in range(d)]
    return solutions

# Examples:
#print (solve_linear_congruence (5, 13, 10)) # 5x ≡ 13 (mod 10)
#print (solve_linear_congruence (6, 14, 10)) # 6x ≡ 14 (mod 10)
#print (solve_linear_congruence (7, 15, 10)) # 7x ≡ 15 (mod 10)

[p, g, beta] = [3584217634602882250414174591984384801148279487761588373233371085330221, 2, 1451442262502007697556578850467599063162088923187886175571945444277765]
m1 = 'savo laimės bijojo'
[gamma, delta_1] = [945440209744516138616548226081163165473038823895571640695815574665160, 2068807433206076729646832328990880876554706224986519960743371509037857]
m2 = 'praėjo metai kaip viena diena'
[gamma, delta_2] = [945440209744516138616548226081163165473038823895571640695815574665160, 1220812572201474918430115338216212270155395558811595211938516846948257]

x1 = text2number(m1)
x2 = text2number(m2)
power_mod(beta, gamma, p) * power_mod(gamma, delta_1, p) % p == power_mod(g, x1, p)

galimi_k = solve_linear_congruence(delta_1 - delta_2, x1 - x2, p-1)

for i in galimi_k:
    if(power_mod(g, i, p) == gamma):
        k = i # 2. k
        print("2. ", k)

galimi_a = solve_linear_congruence(gamma, x1 - delta_1 * k, p-1)

for i in galimi_a:
    if(power_mod(g, i, p) == beta):
        a = i

[C_1, C_2] = [2715121466653285073308481319598340665356723510927654126626256954631475, 2350394434291369509904974838430562228662382497500579250507778057334814]

M = C_2 / power_mod(C_1, a, p) % p
print("3. ", number2text(M))
